{"version":3,"sources":["../src/actions/describe-image.ts","../src/templates.ts","../src/types.ts","../src/services/image.ts","../src/index.ts"],"sourcesContent":["import {\n    type Action,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n    type HandlerCallback,\n    composeContext,\n    generateObject,\n    type ActionExample,\n    ModelClass,\n    elizaLogger,\n    ServiceType,\n    type IImageDescriptionService,\n} from \"@elizaos/core\";\nimport { getFileLocationTemplate } from \"../templates\";\nimport { FileLocationResultSchema, isFileLocationResult } from \"../types\";\n\nexport const describeImage: Action = {\n    name: \"DESCRIBE_IMAGE\",\n    similes: [\"DESCRIBE_PICTURE\", \"EXPLAIN_PICTURE\", \"EXPLAIN_IMAGE\"],\n    validate: async (_runtime: IAgentRuntime, _message: Memory) => {\n        return true;\n    },\n    description: \"Describe an image\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        // Create context with attachments and URL\n        const getFileLocationContext = composeContext({\n            state,\n            template: getFileLocationTemplate,\n        });\n\n        const fileLocationResultObject = await generateObject({\n            runtime,\n            context: getFileLocationContext,\n            modelClass: ModelClass.SMALL,\n            schema: FileLocationResultSchema,\n            stop: [\"\\n\"],\n        });\n\n        if (\n            !isFileLocationResult(\n                fileLocationResultObject?.object ?? fileLocationResultObject\n            )\n        ) {\n            elizaLogger.error(\"Failed to generate file location\");\n            return false;\n        }\n\n        let fileLocation = (fileLocationResultObject?.object as any)\n            ?.fileLocation;\n        fileLocation ??= fileLocationResultObject;\n\n        const { description } = await runtime\n            .getService<IImageDescriptionService>(ServiceType.IMAGE_DESCRIPTION)\n            .describeImage(fileLocation);\n\n        runtime.messageManager.createMemory({\n            userId: message.agentId,\n            agentId: message.agentId,\n            roomId: message.roomId,\n            content: {\n                text: description,\n            },\n        });\n\n        callback({\n            text: description,\n        });\n\n        return true;\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Can you describe this image for me?\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"Let me analyze this image for you...\",\n                    action: \"DESCRIBE_IMAGE\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"I see an orange tabby cat sitting on a windowsill. The cat appears to be relaxed and looking out the window at birds flying by. The lighting suggests it's a sunny afternoon.\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"What's in this picture?\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"I'll take a look at that image...\",\n                    action: \"DESCRIBE_IMAGE\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"The image shows a modern kitchen with stainless steel appliances. There's a large island counter in the center with marble countertops. The cabinets are white with sleek handles, and there's pendant lighting hanging above the island.\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Could you tell me what this image depicts?\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"I'll describe this image for you...\",\n                    action: \"DESCRIBE_IMAGE\",\n                },\n            },\n            {\n                user: \"{{user2}}\",\n                content: {\n                    text: \"This is a scenic mountain landscape at sunset. The peaks are snow-capped and reflected in a calm lake below. The sky is painted in vibrant oranges and purples, with a few wispy clouds catching the last rays of sunlight.\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n","export const getFileLocationTemplate = `\n{{recentMessages}}\n\nextract the file location from the users message or the attachment in the message history that they are referring to.\nyour job is to infer the correct attachment based on the recent messages, the users most recent message, and the attachments in the message\nimage attachments are the result of the users uploads, or images you have created.\nonly respond with the file location, no other text.\ntypically the file location is in the form of a URL or a file path.\n\n\\`\\`\\`json\n{\n    \"fileLocation\": \"file location text goes here\"\n}\n\\`\\`\\`\n`;\n","import { z } from \"zod\";\n\nexport const FileLocationResultSchema = z.object({\n    fileLocation: z.string().min(1),\n});\n\nexport type FileLocationResult = z.infer<typeof FileLocationResultSchema>;\n\nexport function isFileLocationResult(obj: unknown): obj is FileLocationResult {\n    return FileLocationResultSchema.safeParse(obj).success;\n}\n","import {\n    elizaLogger,\n    getEndpoint,\n    type IAgentRuntime,\n    type IImageDescriptionService,\n    ModelProviderName,\n    models,\n    Service,\n    ServiceType,\n} from \"@elizaos/core\";\nimport {\n    AutoProcessor,\n    AutoTokenizer,\n    env,\n    Florence2ForConditionalGeneration,\n    type Florence2Processor,\n    type PreTrainedModel,\n    type PreTrainedTokenizer,\n    RawImage,\n    type Tensor,\n} from \"@huggingface/transformers\";\nimport sharp, { type AvailableFormatInfo, type FormatEnum } from \"sharp\";\nimport fs from \"fs\";\nimport os from \"os\";\nimport path from \"path\";\n\nconst IMAGE_DESCRIPTION_PROMPT =\n    \"Describe this image and give it a title. The first line should be the title, and then a line break, then a detailed description of the image. Respond with the format 'title\\\\ndescription'\";\n\ninterface ImageProvider {\n    initialize(): Promise<void>;\n    describeImage(\n        imageData: Buffer,\n        mimeType: string\n    ): Promise<{ title: string; description: string }>;\n}\n\n// Utility functions\nconst convertToBase64DataUrl = (\n    imageData: Buffer,\n    mimeType: string\n): string => {\n    const base64Data = imageData.toString(\"base64\");\n    return `data:${mimeType};base64,${base64Data}`;\n};\n\nconst handleApiError = async (\n    response: Response,\n    provider: string\n): Promise<never> => {\n    const responseText = await response.text();\n    elizaLogger.error(\n        `${provider} API error:`,\n        response.status,\n        \"-\",\n        responseText\n    );\n    throw new Error(`HTTP error! status: ${response.status}`);\n};\n\nconst parseImageResponse = (\n    text: string\n): { title: string; description: string } => {\n    const [title, ...descriptionParts] = text.split(\"\\n\");\n    return { title, description: descriptionParts.join(\"\\n\") };\n};\n\nclass LocalImageProvider implements ImageProvider {\n    private model: PreTrainedModel | null = null;\n    private processor: Florence2Processor | null = null;\n    private tokenizer: PreTrainedTokenizer | null = null;\n    private modelId = \"onnx-community/Florence-2-base-ft\";\n\n    async initialize(): Promise<void> {\n        env.allowLocalModels = false;\n        env.allowRemoteModels = true;\n        env.backends.onnx.logLevel = \"fatal\";\n        env.backends.onnx.wasm.proxy = false;\n        env.backends.onnx.wasm.numThreads = 1;\n\n        elizaLogger.info(\"Downloading Florence model...\");\n        this.model = await Florence2ForConditionalGeneration.from_pretrained(\n            this.modelId,\n            {\n                device: \"gpu\",\n                progress_callback: (progress) => {\n                    if (progress.status === \"downloading\") {\n                        const percent = (\n                            (progress.loaded / progress.total) *\n                            100\n                        ).toFixed(1);\n                        const dots = \".\".repeat(\n                            Math.floor(Number(percent) / 5)\n                        );\n                        elizaLogger.info(\n                            `Downloading Florence model: [${dots.padEnd(20, \" \")}] ${percent}%`\n                        );\n                    }\n                },\n            }\n        );\n\n        elizaLogger.info(\"Downloading processor...\");\n        this.processor = (await AutoProcessor.from_pretrained(\n            this.modelId\n        )) as Florence2Processor;\n\n        elizaLogger.info(\"Downloading tokenizer...\");\n        this.tokenizer = await AutoTokenizer.from_pretrained(this.modelId);\n        elizaLogger.success(\"Image service initialization complete\");\n    }\n\n    async describeImage(\n        imageData: Buffer,\n        mimeType: string\n    ): Promise<{ title: string; description: string }> {\n        if (!this.model || !this.processor || !this.tokenizer) {\n            throw new Error(\"Model components not initialized\");\n        }\n        const blob = new Blob([imageData], { type: mimeType });\n        const image = await RawImage.fromBlob(blob);\n        const visionInputs = await this.processor(image);\n        const prompts = this.processor.construct_prompts(\"<DETAILED_CAPTION>\");\n        const textInputs = this.tokenizer(prompts);\n\n        elizaLogger.log(\"Generating image description\");\n        const generatedIds = (await this.model.generate({\n            ...textInputs,\n            ...visionInputs,\n            max_new_tokens: 256,\n        })) as Tensor;\n\n        const generatedText = this.tokenizer.batch_decode(generatedIds, {\n            skip_special_tokens: false,\n        })[0];\n\n        const result = this.processor.post_process_generation(\n            generatedText,\n            \"<DETAILED_CAPTION>\",\n            image.size\n        );\n\n        const detailedCaption = result[\"<DETAILED_CAPTION>\"] as string;\n        return { title: detailedCaption, description: detailedCaption };\n    }\n}\n\nclass AnthropicImageProvider implements ImageProvider {\n    constructor(private runtime: IAgentRuntime) {\n    }\n\n    async initialize(): Promise<void> {\n    }\n\n    async describeImage(\n        imageData: Buffer,\n        mimeType: string,\n    ): Promise<{ title: string; description: string }> {\n        const endpoint = getEndpoint(ModelProviderName.ANTHROPIC);\n        const apiKey = this.runtime.getSetting(\"ANTHROPIC_API_KEY\");\n\n        const content = [\n            {type: \"text\", text: IMAGE_DESCRIPTION_PROMPT},\n            {\n                type: \"image\",\n                source: {\n                    type: \"base64\",\n                    media_type: mimeType,\n                    data: imageData.toString(\"base64\"),\n                },\n            },\n        ];\n\n        const response = await fetch(`${endpoint}/messages`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"x-api-key\": apiKey,\n                \"anthropic-version\": \"2023-06-01\",\n            },\n            body: JSON.stringify(\n                {\n                    model: \"claude-3-haiku-20240307\",\n                    max_tokens: 1024,\n                    messages: [{role: \"user\", content}],\n                }),\n        });\n\n        if (!response.ok) {\n            await handleApiError(response, \"Anthropic\");\n        }\n\n        const data = await response.json();\n        return parseImageResponse(data.content[0].text);\n    }\n}\n\nclass OpenAIImageProvider implements ImageProvider {\n    constructor(private runtime: IAgentRuntime) {}\n\n    async initialize(): Promise<void> {}\n\n    async describeImage(\n        imageData: Buffer,\n        mimeType: string\n    ): Promise<{ title: string; description: string }> {\n        const imageUrl = convertToBase64DataUrl(imageData, mimeType);\n\n        const content = [\n            { type: \"text\", text: IMAGE_DESCRIPTION_PROMPT },\n            { type: \"image_url\", image_url: { url: imageUrl } },\n        ];\n\n        const endpoint =\n            this.runtime.imageVisionModelProvider === ModelProviderName.OPENAI\n                ? getEndpoint(this.runtime.imageVisionModelProvider)\n                : \"https://api.openai.com/v1\";\n\n        const response = await fetch(endpoint + \"/chat/completions\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Bearer ${this.runtime.getSetting(\"OPENAI_API_KEY\")}`,\n            },\n            body: JSON.stringify({\n                model: \"gpt-4o-mini\",\n                messages: [{ role: \"user\", content }],\n                max_tokens: 500,\n            }),\n        });\n\n        if (!response.ok) {\n            await handleApiError(response, \"OpenAI\");\n        }\n\n        const data = await response.json();\n        return parseImageResponse(data.choices[0].message.content);\n    }\n}\n\nclass GroqImageProvider implements ImageProvider {\n    constructor(private runtime: IAgentRuntime) {}\n\n    async initialize(): Promise<void> {}\n\n    async describeImage(\n        imageData: Buffer,\n        mimeType: string\n    ): Promise<{ title: string; description: string }> {\n        const imageUrl = convertToBase64DataUrl(imageData, mimeType);\n\n        const content = [\n            { type: \"text\", text: IMAGE_DESCRIPTION_PROMPT },\n            { type: \"image_url\", image_url: { url: imageUrl } },\n        ];\n\n        const endpoint =\n            this.runtime.imageVisionModelProvider === ModelProviderName.GROQ\n                ? getEndpoint(this.runtime.imageVisionModelProvider)\n                : \"https://api.groq.com/openai/v1/\";\n\n        const response = await fetch(endpoint + \"/chat/completions\", {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Authorization: `Bearer ${this.runtime.getSetting(\"GROQ_API_KEY\")}`,\n            },\n            body: JSON.stringify({\n                model: /*this.runtime.imageVisionModelName ||*/ \"llama-3.2-90b-vision-preview\",\n                messages: [{ role: \"user\", content }],\n                max_tokens: 1024,\n            }),\n        });\n\n        if (!response.ok) {\n            await handleApiError(response, \"Groq\");\n        }\n\n        const data = await response.json();\n        return parseImageResponse(data.choices[0].message.content);\n    }\n}\n\nclass GoogleImageProvider implements ImageProvider {\n    constructor(private runtime: IAgentRuntime) {}\n\n    async initialize(): Promise<void> {}\n\n    async describeImage(\n        imageData: Buffer,\n        mimeType: string\n    ): Promise<{ title: string; description: string }> {\n        const endpoint = getEndpoint(ModelProviderName.GOOGLE);\n        const apiKey = this.runtime.getSetting(\"GOOGLE_GENERATIVE_AI_API_KEY\");\n\n        const response = await fetch(\n            `${endpoint}/v1/models/gemini-1.5-pro:generateContent?key=${apiKey}`,\n            {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                },\n                body: JSON.stringify({\n                    contents: [\n                        {\n                            parts: [\n                                { text: IMAGE_DESCRIPTION_PROMPT },\n                                {\n                                    inline_data: {\n                                        mime_type: mimeType,\n                                        data: imageData.toString(\"base64\"),\n                                    },\n                                },\n                            ],\n                        },\n                    ],\n                }),\n            }\n        );\n\n        if (!response.ok) {\n            await handleApiError(response, \"Google Gemini\");\n        }\n\n        const data = await response.json();\n        return parseImageResponse(data.candidates[0].content.parts[0].text);\n    }\n}\n\nexport class ImageDescriptionService\n    extends Service\n    implements IImageDescriptionService\n{\n    static serviceType: ServiceType = ServiceType.IMAGE_DESCRIPTION;\n\n    private initialized = false;\n    private runtime: IAgentRuntime | null = null;\n    private provider: ImageProvider | null = null;\n\n    getInstance(): IImageDescriptionService {\n        return ImageDescriptionService.getInstance();\n    }\n\n    async initialize(runtime: IAgentRuntime): Promise<void> {\n        elizaLogger.log(\"Initializing ImageDescriptionService\");\n        this.runtime = runtime;\n    }\n\n    private async initializeProvider(): Promise<boolean> {\n        if (!this.runtime) {\n            throw new Error(\"Runtime is required for image recognition\");\n        }\n\n        const availableModels = [\n            ModelProviderName.LLAMALOCAL,\n            ModelProviderName.ANTHROPIC,\n            ModelProviderName.GOOGLE,\n            ModelProviderName.OPENAI,\n            ModelProviderName.GROQ,\n        ].join(\", \");\n\n        const model = models[this.runtime?.character?.modelProvider];\n\n        if (this.runtime.imageVisionModelProvider) {\n            if (\n                this.runtime.imageVisionModelProvider ===\n                ModelProviderName.LLAMALOCAL ||\n                this.runtime.imageVisionModelProvider ===\n                ModelProviderName.OLLAMA\n            ) {\n                this.provider = new LocalImageProvider();\n                elizaLogger.debug(\"Using local provider for vision model\");\n            } else if (\n                this.runtime.imageVisionModelProvider ===\n                ModelProviderName.ANTHROPIC\n            ) {\n                this.provider = new AnthropicImageProvider(this.runtime);\n                elizaLogger.debug(\"Using anthropic for vision model\");\n            } else if (\n                this.runtime.imageVisionModelProvider ===\n                ModelProviderName.GOOGLE\n            ) {\n                this.provider = new GoogleImageProvider(this.runtime);\n                elizaLogger.debug(\"Using google for vision model\");\n            } else if (\n                this.runtime.imageVisionModelProvider ===\n                ModelProviderName.OPENAI\n            ) {\n                this.provider = new OpenAIImageProvider(this.runtime);\n                elizaLogger.debug(\"Using openai for vision model\");\n            } else if (\n                this.runtime.imageVisionModelProvider === ModelProviderName.GROQ\n            ) {\n                this.provider = new GroqImageProvider(this.runtime);\n                elizaLogger.debug(\"Using Groq for vision model\");\n            } else {\n                elizaLogger.warn(\n                    `Unsupported image vision model provider: ${this.runtime.imageVisionModelProvider}. ` +\n                    `Please use one of the following: ${availableModels}. ` +\n                    `Update the 'imageVisionModelProvider' field in the character file.`\n                );\n                return false;\n            }\n        } else if (\n            model === models[ModelProviderName.LLAMALOCAL] ||\n            model === models[ModelProviderName.OLLAMA]\n        ) {\n            this.provider = new LocalImageProvider();\n            elizaLogger.debug(\"Using local provider for vision model\");\n        } else if (model === models[ModelProviderName.ANTHROPIC]) {\n            this.provider = new AnthropicImageProvider(this.runtime);\n            elizaLogger.debug(\"Using anthropic for vision model\");\n        } else if (model === models[ModelProviderName.GOOGLE]) {\n            this.provider = new GoogleImageProvider(this.runtime);\n            elizaLogger.debug(\"Using google for vision model\");\n        } else if (model === models[ModelProviderName.GROQ]) {\n            this.provider = new GroqImageProvider(this.runtime);\n            elizaLogger.debug(\"Using groq for vision model\");\n        } else {\n            elizaLogger.debug(\"Using default openai for vision model\");\n            this.provider = new OpenAIImageProvider(this.runtime);\n        }\n\n        try {\n            await this.provider.initialize();\n        } catch {\n            elizaLogger.error(\n                `Failed to initialize the image vision model provider: ${this.runtime.imageVisionModelProvider}`\n            );\n            return false;\n        }\n        return true;\n    }\n\n    private async loadImageData(\n        imageUrlOrPath: string\n    ): Promise<{ data: Buffer; mimeType: string }> {\n        let loadedImageData: Buffer;\n        let loadedMimeType: string;\n        const { imageData, mimeType } = await this.fetchImage(imageUrlOrPath);\n        const skipConversion =\n            mimeType === \"image/jpeg\" ||\n            mimeType === \"image/jpg\" ||\n            mimeType === \"image/png\";\n        if (skipConversion) {\n            loadedImageData = imageData;\n            loadedMimeType = mimeType;\n        } else {\n            const converted = await this.convertImageDataToFormat(\n                imageData,\n                \"png\"\n            );\n            loadedImageData = converted.imageData;\n            loadedMimeType = converted.mimeType;\n        }\n        if (!loadedImageData || loadedImageData.length === 0) {\n            throw new Error(\"Failed to fetch image data\");\n        }\n        return { data: loadedImageData, mimeType: loadedMimeType };\n    }\n\n    private async convertImageDataToFormat(\n        data: Buffer,\n        format: keyof FormatEnum | AvailableFormatInfo = \"png\"\n    ): Promise<{ imageData: Buffer; mimeType: string }> {\n        const tempFilePath = path.join(\n            os.tmpdir(),\n            `tmp_img_${Date.now()}.${format}`\n        );\n        try {\n            await sharp(data).toFormat(format).toFile(tempFilePath);\n            const { imageData, mimeType } = await this.fetchImage(tempFilePath);\n            return {\n                imageData,\n                mimeType,\n            };\n        } finally {\n            fs.unlinkSync(tempFilePath); // Clean up temp file\n        }\n    }\n\n    private async fetchImage(\n        imageUrlOrPath: string\n    ): Promise<{ imageData: Buffer; mimeType: string }> {\n        let imageData: Buffer;\n        let mimeType: string;\n        if (fs.existsSync(imageUrlOrPath)) {\n            imageData = fs.readFileSync(imageUrlOrPath);\n            const ext = path.extname(imageUrlOrPath).slice(1).toLowerCase();\n            mimeType = ext ? `image/${ext}` : \"image/jpeg\";\n        } else {\n            const response = await fetch(imageUrlOrPath);\n            if (!response.ok) {\n                throw new Error(\n                    `Failed to fetch image: ${response.statusText}`\n                );\n            }\n            imageData = Buffer.from(await response.arrayBuffer());\n            mimeType = response.headers.get(\"content-type\") || \"image/jpeg\";\n        }\n        return { imageData, mimeType };\n    }\n\n    async describeImage(\n        imageUrlOrPath: string\n    ): Promise<{ title: string; description: string }> {\n        if (!this.initialized) {\n            this.initialized = await this.initializeProvider();\n        }\n\n        if (this.initialized) {\n            try {\n                const { data, mimeType } =\n                    await this.loadImageData(imageUrlOrPath);\n                return await this.provider.describeImage(data, mimeType);\n            } catch (error) {\n                elizaLogger.error(\"Error in describeImage:\", error);\n                throw error;\n            }\n        }\n    }\n}\n\nexport default ImageDescriptionService;\n","import type { Plugin } from \"@elizaos/core\";\n\nimport { describeImage } from \"./actions/describe-image.ts\";\nimport {\n    ImageDescriptionService,\n} from \"./services/image\";\n\nexport type NodePlugin = ReturnType<typeof createNodePlugin>;\n\nexport function createNodePlugin() {\n    return {\n        name: \"default\",\n        description: \"Default plugin, with basic actions and evaluators\",\n        services: [\n            new ImageDescriptionService(),\n        ],\n        actions: [describeImage],\n    } as const satisfies Plugin;\n}\n"],"mappings":"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","names":["elizaLogger","ServiceType"]}